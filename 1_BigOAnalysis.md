Оценка сложности алгоритмов привязана не ко времени (зависит от конфигурации устройства), а к количеству совершаемых операций процессором.
Главная идея Big O заключается в том, что от количества передаваемых параметром зависит количество совершенных операций, прежде чем алгоритм завершится.
Нотация Big O проводит оценку на наихудший сценарий выполнения. То есть алгоритм никогда не будет медленнее, чем его оценка по Big O.

Сложность алгоритмов (от самой быстрой до самой медленной):
1) O(1) - константная - цикл с константным количеством итераций
2) О(sqrt(N)) - сублиненая - цикл с квадратом переменной в условии
3) О(log N) - логарифмическая - бинарный поиск
4) О(N) - линейная - цикл от переменной
5) O(N * log N) - линейно-логарифмическая - быстрая сортировка
5) O(N^2) - квадратичная - вложенный цикл
6) O(2^N) - эспоненциальная - два рекурсивных вызова
7) O(N!) - факториальная - перестановка значений массива

Различные разряды функций растут с разным темпом, поэтому их нельзя сравнивать друг с другом.
Константные операции не в константом разряде сложности отбрасываются, т.к. сложность алгоритма не должна зависеть от способностей оборудования. А её акцент должен быть на том КАК ФУНКЦИЯ РОСТЕТ при увеличении аргумента - так они и распределены на разряды.

Если алгоритм зависит более чем от одного аргумента, то нужно указать их все.

Алгоритм можно оценивать как сложность по процессору и сложность по памяти.
Сложность по памяти для циклических функций - константная, а для рекурсивных - линейная.